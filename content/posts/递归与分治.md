+++
title = '递归与分治'
date = 2024-02-27T22:03:04+08:00
draft = true
+++

## 经典汉诺塔

这题是在学校的算法书上看到的（陈慧南著）

之前在b站上也看到类似讲解，但是没有看懂题意，今天和舍友一起讨论这题讨论了三个小时（终于搞懂），这道题目思想很深，收获很大

题目如下：

n个圆盘从下面开始按大小顺序摆放在A柱子上。并且规定，任何时候，在小圆盘上都不能放大圆盘，且在三根柱子之间一次只能移动一个圆盘，求最少的移动步骤（描述出来）。

这里吐槽一下学校的书，只简单说一下汉诺塔，就直接摆出代码（）

你好歹说一下我要求什么吧（就说一下求个最少移动次数描述就行了 或者说求最少移动次数）

描述形式 ：每次移动的盘子+所在柱子+移动到的柱子

### 递归形式

先给题解：

```c++
    #include <iostream>
    using namespace std;

    void move(char a,char c,int k){//把k个盘子从a柱子移到c柱子（b柱子作为辅助）
        cout << k << ":"<<a<<"-->"<<c<<endl;
    }//最小化问题
    //Hanoi(a,c,b,k) = Hanoi(a,b,c,k-1) + move(a,c,k) + Hanoi(b,c,a,k-1)
    void Hanoi(char a,char c,char b,int k){//k个盘子
        if(k){//当k>0
            Hanoi(a,b,c,k-1);//子问题1
            move(a,c,k);
            Hanoi(b,c,a,k-1);//子问题2
        }
    }
    int main(){
        int k;
        cin >> k;
        Hanoi('a','c','b',k);//总问题
        return 0;
    }

```

这是最简单的形式

这里直接给出递归算法的形式：

Hanoi(a,c,b,k) = Hanoi(a,b,c,k-1) + move(a,c,k) + Hanoi(b,c,a,k-1)

注意：Hanoi(a,c,b,k)算法含义是把k个盘子从a柱子移到c柱子(b柱子作为辅助)

move(a,c,k)表示把编号为k的盘子从a移到c

可能有的刚学递归或者没学递归的同学直接看这个式子是一脸懵（在下也是）

#### 递归的本质

这里说一下本座对 **递归的理解**：

1.递归思想是说我们要求的的问题的解实际上是一棵树，书上挂满的节点就是所有的解

这样能说可能很抽象）

2.递归思想又叫最小化问题，比如这里的问题是求解所有的移动过程（移动次数最小的情况），可以看出来本身这个问题是非常棘手的，但是你看，如果盘子只有一个，你当然知道是把这个盘子从a移到c（也就是我写的move函数）

3.而最小的这个问题就是树的子节点

那么问题的本质就变成求出那个问题的最小化问题，而总问题因为分出一个最小化问题而变成一个小一点的子问题（之后不断的缩小全部变成最小化问题），就得到了问题的解

#### 结合本题

再来看这道题

子问题1就是描述上面k-1个盘子从a移到b的过程

最小化问题就是描述把最下面那个盘子（k）移动的过程(a-->c)（理由看理解3）

子问题2就是描述上面k-1个盘子从b移到c的过程

### 迭代形式

迭代形式就相当复杂了，这也是我和舍友讨论最久的一种解法（参考某位大佬）

先给题解：

观察规律：

有递归算法：

Hanoi(a,c,b,k) = Hanoi(a,b,c,k-1) + move(a,c,k) + Hanoi(b,c,a,k-1)

1.这里是一颗二叉树，你自己去模拟移动盘子的过程：先从子节点到子节点的父节点，再到父节点的另一个子节点，该大佬发现这和二进制非常的像（太妙了），比如001，010，011，100···

不断加一的过程中，最后一位的1所处的位置就是该节点所在二叉树的层数，既然知道了移动的次数，就得到对应二进制数的最后一位1所处位置（也就是所在二叉树的层数），就是移动盘子的序号

2.光知道移动的盘子序号也是没用的，你不知道从哪移到哪啊，于是大佬又发现一个牛逼的规律：

设a-->c-->b-->a是正方向，反之则是反方向

k，k-1，k-4，k-5···盘子是正方向

k-2，k-3,k-6,k-7···盘子是反方向

由Hanoi(a,c,b,k) = Hanoi(a,b,c,k-1) + move(a,c,k) + Hanoi(b,c,a,k-1)

最大的盘子a-->c是正方向，第二大的盘子a-->b b-->c是正方向···

最后推出来这么个规律（晕）

知道这两个规律后（发现了很多哎，但还是不会写（雾））

大佬又用了一个二维数组表示从哪移到哪`a[0]['a'] == 'c'`

0是正方向，1是反方向

## 排列产生算法(全排列-递归形式)

题解：

```c++

```
