+++
title = '基本技巧'
date = 2024-02-12T21:10:09+08:00
draft = true
+++
持续更新！！！

总结各路高手的技巧和牛笔思维

## 常用c++容器

注意：还有大量补充，请自行查阅 **cppreference**

vector

queue(队列)/prioritiy_queue(优先队列)

stack栈

map/unordered_map(前者是红黑树实现，后者是哈希表实现)

set/unordered_set(前者是红黑树实现，后者是哈希表实现)

使用示范代码如下：

```c++
#include <iostream>
//所用头文件如下
#include <vector>
#include <queue>
#include <stack>
#include <map>
#include <set>

using namespace std;

//最基本的容器
int main(){
    // //vector
    // vector <double> b;
    // for(int i =0;i<10;i++){
    //     b.push_back(i*10);//增加操作
    // }
    // int size = b.size();
    // // for(int i =0;i<size;i++){
    // //     cout<<b[i]<<" \n"[&b[i] == &b.back()];
    // // }
    // for(auto s = b.begin();s != b.end();s++){
    //     cout<<*s<<" ";
    // }
    // cout<<"\n";
    // b.erase(b.begin(),b.end());//删除操作
    // int num = b.size();//vector的元素数
    // if(!num)cout <<"ERROR";
    // else 
    // for(int i =0;i<num;i++){
    //     cout<<b[i]<<" \n"[&b[i] == &b.back()];//使用上次所学
    // }
    // cout<<"\n";
    // //stack栈
    // stack<int> a;
    // for(int i = 0;i<10;i++){
    //     a.push(i);
    // }
    // while(!a.empty()){
    //     cout<<a.top()<<" ";
    //     a.pop();
    // }
    // cout<<endl;
    // //队列
    // queue<int> c;
    // for(int i =0;i<10;i++){
    //     c.push(i);
    // }
    // while(!c.empty()){
    //     cout<<c.front()<<" ";//队头元素
    //     c.pop();//删除队头元素
    // }
    //优先队列(大顶堆)priority_queue
    priority_queue<int> d;//大顶堆
    priority_queue<int ,vector<int>, greater<int>> e;//小顶堆
    //map/set(红黑树实现)
    //unordered_map/unordered_set未排序的,用法基本一样，（哈希实现）

    map<int,string> f;
    set<int> g;
    for(int i =0;i<10;i++){
        f[i]="aaa";
        g.insert(i);
    }
    //f.erase(f.begin());
    g.erase(g.begin());
    for(auto i:g){
        // cout<<i.first<<" "<<i.second<<endl;//first是键，second是值
        cout<<i<<endl;
    }  
    // cout<<f.count(4)<<endl;//查询时填的是键
    // f.clear();
    // cout<<f.count(4);//查询时填的是键
    cout<< g.count(2);
}
```

## 常用c++函数

### STL里的sort函数（数据少且大）

使用sort()函数前需要引入头文件 ` #include <algorithm> `

内部实现是 **快速排序**，复杂度是 **O(nlogn)**

在 `vector` 中使用 `sort(a.begin(),a.end())`，C数组中用sort(a, a + n)进行排序。

缺点是数据量大的情况会很慢

据高手笔记：**一般在数据范围1~10 ^ 6以内可以用快速排序，且元素的大小一般很大**

### 自己写 桶排序（数据多且在一定范围）

桶排序例题[桶排序](https://www.luogu.com.cn/problem/P1271 "桶")

```c++
  for(int i = 1;i <= m; ++ i)
    {
        int x;cin >> x;
        a[x] ++;//桶号就是存在的数
    }
    for(int i = 0;i <= n; ++ i)//遍历范围里的所有数字
    {
        for(int j = 1;j <= a[i]; ++ j)//桶里有就输出桶号
        {
            cout << i << ' ';
        }
    }
```

### transform函数

如果使用string类，可以使用`#include <algorithm>`里的如下方法进行大小写转换；

　　`transform(str.begin(),str.end(),str.begin(),::tolower);`

重点：是`::tolower`，大转小，小转大

自己写[题目](https://ac.nowcoder.com/acm/problem/265218 "1")

```c++
#include <bits/stdc++.h>

using namespace std;

char trans(char& a){
    if(a>='A'&&a<='Z'){//判断是大写字母
        a+=32;
    }
    return a;
}//转成小写字母

int main(){
    int t;
    cin>>t;
    while(t--){
    string s1,s2;
    cin>>s1>>s2;
    if(trans(s1[0])==trans(s2[0]))
        cout<<"Yes"<<endl;
    else
        cout<<"No"<<endl;
    }
    return 0;
}
```

## 语法糖

### foreach循环

`for(auto  &i : a)`

循环中i就是要遍历的元素，对i进行操作

每组数据后输出一个 `\n`

学习自某位大佬的写法（mobai @_@）
`"\n"[&i == &a.back()];`迭代器到最后一位时输出回车
