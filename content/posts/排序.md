+++
title = '排序'
date = 2024-02-27T22:11:13+08:00
draft = true
+++

某次学校实验实现的基本排序

数据结构这门课难在麻烦之上，

每次实验都要封装一些数据结构（当时傻，每次还重写又臭又长的宏定义，学生思维太重），

并且要写检查程序（自己写的也是很麻烦（其实没必要）），加之本人上机代码敲的巨慢，

最终数据结构这门课没学到点上

排除个人菜的问题，学校的实验题目太宽泛了（没要学我下面写那么长），像我这种菜鸟写的代码又臃肿又容易出bug

不由感觉提升代码水平全得靠自己疯狂折腾 ~_~

## 基本的数据封装

```c++
#include "stdio.h"
#include <iostream>
#include <ctime>
#include <cstdlib>


#define ERROR 0
#define OK 1
#define Overflow 2
#define Underflow 3
#define NotPresent 4    //元素不存在
#define Duplicate 5 //元素重复存在
#define MaxSize 100001
typedef int KeyType;
typedef int Status;
typedef int DataType;

typedef struct Entry{
    KeyType key;
    DataType data;
}entry;

typedef struct list{
    int n;
    Entry D[MaxSize];
}List;

//输出函数
Status printlist(list*l){
    for(int i = 0;i<l->n;i++){
        printf("%d ",l->D[i].key);
    }
    return OK;
}

void swap(Entry* a, Entry* b) {
    Entry temp = *a;
    *a = *b;
    *b = temp;
}
```

## 简单选择排序

```c++
Status choosesort(list* l){
    for(int i = 0;i<l->n-1;i++){
        int min = i;
        for(int j =i+1;j<l->n;j++){
            if(l->D[min].key>l->D[j].key)
                min = j;
        }
        swap(&l->D[i],&l->D[min]);
    }
    return OK;
}
```

## 直接插入排序

```c++
Status insertsort(list*l){
    int i,j;
    for(i=1;i<l->n;i++){
        Entry temp = l->D[i];
        j=i-1;
        while(j>=0){
            if(l->D[j].key>temp.key){
                l->D[j+1] = l->D[j];
                l->D[j] = temp;
            }
            j--;
        }
    }
    return OK;
}

```

## 冒泡排序

```c++
void Bubblesort(list*l){
    for(int i = 0;i<l->n-1;i++) {
        int start = 0, end = 1;
        while (end < l->n) {
            if (l->D[start].key > l->D[end].key) {
                Entry temp = l->D[start];
                l->D[start] = l->D[end];
                l->D[end] = temp;

            }
            ++start;
            ++end;
        }
    }
}

```

## 快速排序

```c++
void QuickSort(List* l, int low, int high) {   //快速排序->递归函数
    if (low < high) {                            //当前待排序序列至少包含2个元素，故low必须<high
        int i = low;
        int j = high;
        Entry min = l->D[low];//标准位置先设置成low
        while (i<j){
            while (i<j&&l->D[j].key>min.key){
                j--;
            }
            if(i<j)
                l->D[i++]=l->D[j];
            while(i<j&&l->D[i].key<min.key){
                i++;
            }
            if(i<j)
                l->D[j--]=l->D[i];
        }
        l->D[i] = min;
        QuickSort(l, low, i - 1);//i前面的递归
        QuickSort(l, i + 1, high);//i后面的递归
    }
}

```

//快排太精妙了 所以学过一段时间就忘 不知道有些人怎么记住那么久的

## 两路合并排序

两路合并排序使用了分治法策略

```c++
void merge(list*l,int left,int lmid,int rmid,int right){
    int i = left,j=rmid;//i,j指向left 和right
    list temp;
    int index = 0;
    while(i<=lmid&&j<=right){
        if(l->D[i].key<=l->D[j].key){
            temp.D[index++]=l->D[i++];
        }
        else{
            temp.D[index++]=l->D[j++];
        }
    }
    while(i<=lmid){
        temp.D[index++]=l->D[i++];
    }
    while (j<=right){
        temp.D[index++]=l->D[j++];
    }
    int n=0;
    for(int k = left;k<=right;k++){
        l->D[k]=temp.D[n++];
    }
}

//这里的处理太傻逼了 还新建了一个链表 但实际怎么做捏 无语

Status mergesort(list*l,int left,int right){
    if(left<right){
        int mid = left+(right-left)/2;
        mergesort(l,left,mid);
        mergesort(l,mid+1,right);
        merge(l,left,mid,mid+1,right);
    }
    return OK;
}
```

## 堆排序

```c++
void downadjust(list*l,int start,int end){//调整堆
    Entry temp = l->D[start];
    for(int i = 2*start+1;i<=end;i*=2){//从start结点的左子结点开始
        if(i<end&&l->D[i].key>l->D[i+1].key)//如果左子结点小于右子结点
            i++;//i指向右子结点
        if(temp.key>=l->D[i].key)//如果父结点大于子结点
            break;//调整结束
        l->D[start] = l->D[i];//否则将子结点值赋给父结点
        start = i;//重新赋值开始指针
    }
    l->D[start] = temp;//调整结束后，将temp值放在最终位置
}
Status heapsort(list*l){//堆排序
    for(int i = l->n/2;i>=0;i--){//建堆
        downadjust(l,i,l->n);//调整堆
    }
    return OK;
}
```

## 测试

### 数据封装（随机数）

```c++
list* initlist(int n){//在list里生成n个随机数
    list *l;
    l=(list*) malloc(sizeof (list));
    l->n = n;
    if(n>MaxSize)
        return nullptr;
    srand(time(0));//生成随机种子
    for(int i = 0;i<n;i++){
        l->D[i].key=(rand()%1000)+1;//随机数赋值
        l->D[i].data = (rand()%50)+1;
    }
    return l;
}
```

### 检查程序

```c++
void deletelist(list*l){
    if(!l)
        return;
    free(l);
}

Status testchoosesort(int n){
    list *l0 = initlist(n);
    printf("\n\nmake a new list!\n");
    printlist(l0);
    clock_t start,finish;
    start = clock();
    choosesort(l0);
    finish = clock();
    printf("\nafter choosesort\n");
    double TheTimes;
    printlist(l0);
    TheTimes=(double)(finish-start)/CLOCKS_PER_SEC;
    printf("消耗%f秒。\n",TheTimes);
    deletelist(l0);
    return OK;
}

Status testinsertsort(int n){
    list *l0 = initlist(n);
    printf("\n\nmake a new list!\n");
    printlist(l0);
    clock_t start,finish;
    start = clock();
    insertsort(l0);
    finish=clock();
    double TheTimes;
    printf("\nafter insertsort\n");

    printlist(l0);
    TheTimes=(double)(finish-start)/CLOCKS_PER_SEC;
    printf("消耗%f秒。\n",TheTimes);
    deletelist(l0);
    return OK;
}

Status testBubblesort(int n){
    list *l0 = initlist(n);
    printf("\n\nmake a new list!\n");
    printlist(l0);
    clock_t start,finish;
    start = clock();
    Bubblesort(l0);
    finish=clock();
    printf("\nafter bubblesort\n");
    double TheTimes;
    printlist(l0);
    TheTimes=(double)(finish-start)/CLOCKS_PER_SEC;
    printf("消耗%f秒。\n",TheTimes);
    deletelist(l0);
    return OK;
}
//测试程序 500 1000 5000 10000
Status testquicksort(int n){
    list *l0 = initlist(n);
    printf("\n\nmake a new list!\n");
    printlist(l0);
    clock_t start,finish;
    start = clock();
    QuickSort(l0,0,l0->n-1);
    finish=clock();
    double TheTimes;
    printf("\nafter quicksort\n");
    printlist(l0);
    TheTimes=(double)(finish-start)/CLOCKS_PER_SEC;
    printf("消耗%f秒。\n",TheTimes);
    deletelist(l0);
    return OK;
}
Status testmergesort(int n){
    list *l0 = initlist(n);
    printf("\n\nmake a new list!\n");
    printlist(l0);
    clock_t start,finish;
    start = clock();
    mergesort(l0,0,n-1);
    finish=clock();
    double TheTimes;
    printf("\nafter mergesort\n");
    printlist(l0);
    TheTimes=(double)(finish-start)/CLOCKS_PER_SEC;
    printf("消耗%f秒。\n",TheTimes);
    deletelist(l0);
    return OK;
}

Status testheapsort(int n){
    list *l0 = initlist(n);
    printf("\n\nmake a new list!\n");
    printlist(l0);
    heapsort(l0);
    printf("\nafter heapsort\n");
    printlist(l0);
    deletelist(l0);
    return OK;
}




int main(){
    testinsertsort(500);
    testchoosesort(500);
    testBubblesort(500);
    testquicksort(500);
    testmergesort(500);
    return 0;
}
```
